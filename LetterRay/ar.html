<html>
  <head>
    <title>360View</title>
    <style>
a-scene, #a-scene {
  height: 150px;
  width: 150px;
}    
</style>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/gnat/surreal@main/surreal.js"></script>
    <script>
AFRAME.registerComponent('hide-in-ar-mode', {
  init: function () {
    this.el.sceneEl.addEventListener('enter-vr', (ev) => {
    if (this.el.sceneEl.is('ar-mode')) {
      this.el.setAttribute('visible', false);
    }
    });
    this.el.sceneEl.addEventListener('exit-vr', (ev) => {
    this.el.setAttribute('visible', true);
    });
  }
})
AFRAME.registerPrimitive('a-hud', {
    defaultComponents: {
        hud: { },
    },
    mappings: {
        radius: 'hud.radius',
        'horizontal-fov': 'hud.horizontalFov',
        'vertical-fov': 'hud.verticalFov',
        'scale-factor': 'hud.scaleFactor',
	}
});

AFRAME.registerPrimitive('a-hud-element', {
    defaultComponents: {
		'hud-element': { },
	},
	mappings: {
        align: 'hud-element.align',
        anchor: 'hud-element.anchor',
        'content-size': 'hud-element.contentSize',
        'hud-size': 'hud-element.hudSize',
	}
});

AFRAME.registerComponent('hud', {
    schema: {
        radius: { type: 'number', default: 1 },
        horizontalFov: { type: 'number', default: 80 },
        verticalFov: { type: 'number', default: 60 },
        scaleFactor: { type: 'number', default: 1.0 },
    },
    init: function() {
        this.flat = true;
        this.el.sceneEl.addEventListener('rendererresize', () => {
            // Relayout is only needed on resize if the layout is flat (= screen space)
            if(this.flat) {
                this.relayout()
            }
        });
        this.el.sceneEl.addEventListener('enter-vr', () => {
            this.flat = false;
            this.relayout();
        });
        this.el.sceneEl.addEventListener('exit-vr', () => {
            this.flat = true;
            this.relayout();
        });
    },
    relayout: function() {
        for(const child of this.el.children) {
            if(child.components['hud-element']) {
                child.components['hud-element'].layout(this)
            }
        };
    },
    convertCoordinates: function(coordinates, outV3) {
        if(this.flat) {
            const camera = this.el.sceneEl.camera;
            const yScale = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom;
            const xScale = yScale * camera.aspect;

            outV3.set(coordinates.x * xScale, coordinates.y * yScale, -1);
        } else {
            // Compute spherical coordinates
            const theta = - this.data.horizontalFov/2.0 * coordinates.x;
            const phi = -90 + this.data.verticalFov/2.0 * coordinates.y;

            outV3.set(
                Math.sin(THREE.MathUtils.DEG2RAD*phi) * Math.sin(THREE.MathUtils.DEG2RAD*theta),
                Math.cos(THREE.MathUtils.DEG2RAD*phi),
                Math.sin(THREE.MathUtils.DEG2RAD*phi) * Math.cos(THREE.MathUtils.DEG2RAD*theta));
            outV3.multiplyScalar(this.data.radius);
        }
    },
    convertWidth: function(width) {
        return this.flat ? width * this.data.scaleFactor : width;
    },
    convertHeight: function(height) {
        // Height is given in "width percentage", so needs to be adjusted based on aspect ratio.
        const adjustedHeight = height * this.aspectRatio();
        return this.flat ? adjustedHeight * this.data.scaleFactor : adjustedHeight;
    },
    aspectRatio: function() {
        if(this.flat) {
            return this.el.sceneEl.camera.aspect;
        }
        return this.data.horizontalFov / this.data.verticalFov;
    },
    scale: function() {
        if(this.flat) {
            const camera = this.el.sceneEl.camera;
            const yScale = Math.tan(THREE.MathUtils.DEG2RAD * 0.5 * camera.fov) / camera.zoom;
            return 2.0 * yScale * camera.aspect * this.data.scaleFactor;
        }
        return this.data.horizontalFov/360 * this.data.radius*Math.PI*2.0;
    },
    orientate: (function() {
        const tempMat4 = new THREE.Matrix4();
        const up = new THREE.Vector3(0, 1, 0);
        const origin = new THREE.Vector3(0, 0, 0);
        return function(position, outQuaternion) {
            if(this.flat) {
                outQuaternion.identity();
                return;
            }

            tempMat4.lookAt(origin, position, up);
            outQuaternion.setFromRotationMatrix(tempMat4);
        };
    })()
});

/* Normalized coordinates lookup for anchor/align points */
const COORDINATES = {
    'top-left': new THREE.Vector2(-1.0, 1.0),
    'top': new THREE.Vector2(0.0, 1.0),
    'top-right': new THREE.Vector2(1.0, 1.0),
    'right': new THREE.Vector2(1.0, 0.0),
    'bottom-right': new THREE.Vector2(1.0, -1.0),
    'bottom': new THREE.Vector2(0.0, -1.0),
    'bottom-left': new THREE.Vector2(-1.0, -1.0),
    'left': new THREE.Vector2(-1.0, 0.0),
    'center': new THREE.Vector2(0.0, 0.0),
};

AFRAME.registerComponent('hud-element', {
    schema: {
        align: { type: 'string', default: 'center' },
        anchor: { type: 'string', default: 'center' },
        contentSize: { type: 'vec2', default: new THREE.Vector2(1.0, 1.0) },
        hudSize: { type: 'number', default: 1.0 },
    },
    init: function() {
        this.coordinates = new THREE.Vector2();
    },
    update: function() {
        const hud = this.el.parentElement.components['hud'];
        if(hud) {
            this.layout(hud);
        }
    },
    layout: function(hud) {
        const aspect = this.data.contentSize.y / this.data.contentSize.x;

        const coordinates = this.coordinates.copy(COORDINATES[this.data.align]);
        const anchor = COORDINATES[this.data.anchor];
        coordinates.x -= anchor.x * hud.convertWidth(this.data.hudSize);
        coordinates.y -= anchor.y * hud.convertHeight(this.data.hudSize * aspect);
        hud.convertCoordinates(coordinates, this.el.object3D.position);

        const scale = hud.scale() * this.data.hudSize / this.data.contentSize.x;
        this.el.object3D.scale.set(scale, scale, scale);

        hud.orientate(this.el.object3D.position, this.el.object3D.quaternion);
    }
});

AFRAME.registerGeometry('star', {
  schema: {
    points: {default: 5},
    outerRadius: {default: 3},
    innerRadius: {default: 1},
    depth: {default: 0.5},
  },

  init: function (data) {

    var starPoints = [];
    const radii = [data.outerRadius, data.innerRadius]
    var toggle = 0
    for (var ii = 0; ii < (data.points * 2); ii++) {
      const angle = (ii * Math.PI * 2)/data.points;
      const x = radii[toggle] * Math.sin(angle)
      const y = radii[toggle] * Math.cos(angle)

      toggle = 1 - toggle;

      starPoints.push(new THREE.Vector2 (x, y));
    }

    var starShape = new THREE.Shape(starPoints);

    var extrusionSettings = {
        curveSegments: 5,
        depth: data.depth,
        bevelEnabled: false
    };

    var starGeometry = new THREE.ExtrudeGeometry(starShape, extrusionSettings);

    this.geometry = starGeometry;
    recenterGeometry(this.geometry);
  }
});

 AFRAME.registerComponent("layers", {
    // A-Frame's built-in array type wasn't working, so an array-like string will
    // be parsed manually. e.g. "1, 2, 3" => [1, 2, 3].
    schema: {
      default: "0",
    },
  
    update: function (oldData) {
      const el = this.el;
      const data = this.data;
      const layerNumbers = data.split(",").map(Number);
  
      // To manipulate layers of both camera AND meshes, iterate through all
      // Object3Ds associated with the entity this component is attached to.
      const objectMap = el.object3DMap;
      for (let obj of Object.values(objectMap)) {
        if (!obj.layers) {
          return;
        }
  
        // Reset
        obj.layers.disableAll();
  
        // Apply
        for (let num of layerNumbers) {
          obj.layers.enable(num);
        }
      }
      
      
    },
    
  
  });


    </script>
  </head>
  <body>

<div id="a-scene">
    <a-scene id="thescene" xrweb="mode: immersive-ar; optionalFeatures: dom-overlay; overlayElement: #overlay"
    xr-mode-ui="enabled: true; enterAREnabled: true; XRMode: ar;"
    renderer="colorManagement: true; antialias: true; foveationLevel: 0" embedded>

    <a-sky color = "#000337"  hide-in-ar-mode>
    </a-sky>
    <a-entity 
        id="player" 
        position="0 0 0" >
        <a-camera id="thecamera" fov="80" far="10000" near="0.005">
                    <a-hud id="hud" horizontal-fov="60" vertical-fov="45" scale-factor=".5">
                        <a-hud-element align="center" content-size="2.0 0.1" hud-size="0.5" anchor="left" id="hudleft">		  
<a-entity id="left" scale=".35 1 .5" position=".1 -.5 0" geometry="primitive: star" material="color:black; opacity:.88" layers="2"></a-entity>
		</a-hud-element>
		    <a-hud-element align="center" content-size="2.0 0.1" hud-size="0.5" anchor="right" id="hudright">
<a-entity id="right" scale=".35 1 .5" position="-.1 -.5 0" geometry="primitive: star" material="color:black; opacity:.88" layers="1"></a-entity>		  
		</a-hud-element>
                    </a-hud>
		</a-camera>
    </a-entity>

      </a-scene>  
</div>

<form id="settings">
</form>
<div id="container">
</div>
<script>
var ui = [
  {"label": "Renderer", "id":"thescene", "attribute":"renderer"},
  /*{"label": "Camera fov", "id":"thecamera", "attribute":"fov"},
  {"label": "Camera far", "id":"thecamera", "attribute":"far"},
  {"label": "Camera near", "id":"thecamera", "attribute":"near"},
  {"label": "HUD Left Content Size", "id":"hudleft", "attribute":"content-size"},
  {"label": "HUD Right Content Size", "id":"hudright", "attribute":"content-size"},
  {"label": "Horizontal fov", "id":"hud", "attribute":"horizontal-fov"},
  {"label": "Vertical fov",  "id":"hud", "attribute":"vertical-fov"},
  {"label": "Scale factor", "id":"hud", "attribute":"scale-factor"},
  {"label": "Hud Size left", "id":"hudleft", "attribute":"hud-size"},
  {"label": "Hud Size right", "id":"hudright", "attribute":"hud-size"},
  */{"label": "Left position", "id":"left", "attribute":"position"},
  {"label": "Right position", "id":"right", "attribute":"position"},
  {"label": "Left scale", "id":"left", "attribute":"scale"},
  {"label": "Right scale", "id":"right", "attribute":"scale"},
  {"label": "Box position", "id":"box", "attribute":"position"},
  {"label": "Box rotation", "id":"box", "attribute":"rotation"},
];

  function load(ui) {
    ui.forEach(function(data, index) {
      me('#settings').insertAdjacentHTML('beforeend',`<label>${data['label']}<input id="input${data['id']}-${data['attribute']}" name="input${data['id']}-${data['attribute']}" type="text" /></label><br />`);  
      me(`#input${data['id']}-${data['attribute']}`).value = me(`#${data['id']}`).getAttributeNode(data['attribute']).value
      me(`#input${data['id']}-${data['attribute']}`).on("change", ev => { 
        me(`#${data['id']}`).attribute(data['attribute'], ev.srcElement.value)
      })
    });
  }
  load(ui);

  function populate(ui) {
    ui.forEach(function(data, index) {
      let v = me(`#input${data['id']}-${data['attribute']}`).value
      me(`#${data['id']}`).attribute(data['attribute'], v)
      })
    };


  // where to put buttons
  const htmlnode = document.querySelector('#container');
  // form to parse
  const formel = document.querySelector('form#settings');
  const extractfields = document.createElement("button");
  extractfields.innerText="Extract";
  extractfields.onclick = () => {
      let formlength = formel.elements.length; 
      let json = {}
      for (i=0; i<formlength; i++) {
          var type = formel.elements[i] = type;
          switch(type) {
              case 'checkbox': break;
              default: json[formel.elements[i].name] = formel.elements[i].value; break;
          }
      }
      const datastr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(json));
      const browserfile =  document.createElement('a');
      browserfile.id = "dljson";
      browserfile.setAttribute("href", datastr);
      browserfile.setAttribute("download", "llama.json");
      browserfile.click();
      alert("File Downloaded");
  };

  const loadfields = document.createElement("input");
  loadfields.id = "import-file";
  loadfields.type = "file";
  loadfields.onchange = () => {
      var importFile = document.getElementById('import-file').files[0];      
      var reader = new FileReader();
      reader.onload =  function() {
          const fileContent = JSON.parse(reader.result);
          Object.entries(fileContent).forEach((entry) =>{
              const [key, value] = entry
              const input = document.getElementsByName(key)[0];
                  switch(input){
                      case 'checkbox': break;
                      default: input.value = fileContent[key]; break;
                  }

          })
        populate(ui); 
      };
      reader.readAsText(importFile);			 
  };
  htmlnode.parentNode.insertBefore(loadfields, htmlnode.nextSibling);
  htmlnode.parentNode.insertBefore(extractfields, htmlnode.nextSibling);

  </script>
<br/><br/>
  </body>
</html>
